// Código ESP32: Lectura Wheatstone + SD + MQTT

#include <SPI.h>
#include <SD.h>
#include <WiFi.h>
#include <PubSubClient.h>

#define PIN_VD 34   // Nodo D

// --- Configuración puente ---
const float R2 = 20;
const float Vin = 1.2469;
const float GAIN = 2.0;

// --- SD ---
const int SD_CS_PIN = 5;
File archivo;
unsigned long tiempoInicio = 0;

// --- WiFi --- Configuracion previa
const char* ssid = "CIAM"; // Nombre de la red
const char* password = "0123456789";// Contraseña de la red 

// --- MQTT ---
const char* mqtt_server = "broker.emqx.io"; 
const int mqtt_port = 1883;
WiFiClient espClient;
PubSubClient client(espClient);

// --- Funciones auxiliares ---
float leerPromedio(int pin, int muestras = 10) {
  long suma = 0;
  for (int i = 0; i < muestras; i++) {
    suma += analogRead(pin);
    delay(5);
  }
  return (float)suma / muestras;
}

float filtrar(float nuevo, float anterior, float alfa = 0.2) {
  return alfa * nuevo + (1.0 - alfa) * anterior;
}

float VD_filtrado = 0;
bool primeraLectura = true;

// --- Configuración WiFi ---
void setup_wifi() {
  delay(10);
  Serial.print("Conectando a ");
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("\nWiFi conectado");
  Serial.print("IP: ");
  Serial.println(WiFi.localIP());
}

// --- Reconexión MQTT ---
void reconnect() {
  while (!client.connected()) {
    Serial.print("Conectando a MQTT...");
    if (client.connect("ESP32ClienteEve")) {
      Serial.println("Conectado");
    } else {
      Serial.print("Error, rc=");
      Serial.print(client.state());
      delay(2000);
    }
  }
}

// --- Setup ---
void setup() {
  Serial.begin(115200);
  analogReadResolution(12);

  // SD
  if (!SD.begin(SD_CS_PIN)) {
    Serial.println("Error al iniciar la SD");
  } else {
    archivo = SD.open("/datos.txt", FILE_APPEND);
    if (archivo) {
      archivo.println("\n--- NUEVA SESIÓN ---");
      archivo.println("Tiempo_s,VD_V,Rx_Ohmios");
      archivo.close();
    }
  }

  tiempoInicio = millis();
  Serial.println("Tiempo_s,VD_V,Rx_Ohmios");

  // WiFi + MQTT
  setup_wifi();
  client.setServer(mqtt_server, mqtt_port);
}

// --- Loop ---
void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  unsigned long tiempoActual = millis();
  unsigned long tiempoSegundos = (tiempoActual - tiempoInicio) / 1000;

  float rawVD = leerPromedio(PIN_VD);
  float VD = (rawVD / 4095.0) * 3.7 / GAIN;

  if (primeraLectura) {
    VD_filtrado = VD;
    primeraLectura = false;
  } else {
    VD_filtrado = filtrar(VD, VD_filtrado);
  }

  float Rx = (VD_filtrado * R2) / (Vin - VD_filtrado);
  if (Rx < 0 || VD_filtrado >= Vin || Rx > 100) {
    Rx = -1;
  }

  // Mostrar en Serial
  Serial.printf("%lu, %.2f, %.2f\n", tiempoSegundos, VD_filtrado, Rx);

  // Guardar en SD
  archivo = SD.open("/datos.txt", FILE_APPEND);
  if (archivo) {
    archivo.printf("%lu, %.2f, %.2f\n", tiempoSegundos, VD_filtrado, Rx);
    archivo.close();
  }

  // Publicar en MQTT (topic: sensor/plantas) 
  String payload = String("{\"tiempo\":") + tiempoSegundos +
                   ",\"VD\":" + String(VD_filtrado, 2) +
                   ",\"Rx\":" + String(Rx, 2) + "}";
  client.publish("sensor/plantas", payload.c_str());// 

  delay(1000);
}
